--- 
layout: post
title: Automatic Property Instance Variables with Objective-C
author: Dave Verwer
excerpt: The modern Objective-C runtime includes a great timesaving feature of allowing automatic synthesis of instance variables. This is a great feature but one that I have been reluctant to use (and especially reluctant to teach) as the default implementation of it makes silly mistakes really easy to make.
---
The modern Objective-C runtime includes a great timesaving feature of allowing automatic synthesis of instance variables. This is a great feature but one that I have been reluctant to use (and especially reluctant to teach) as the default implementation of it makes silly mistakes really easy to make.

Take the example of a very simple Person class:

<pre><code class="prettyprint">@interface Person : NSObject

@property (retain) NSString *name;

@end</code></pre>

<pre><code class="prettyprint">@implementation Person

@synthesize name;

- (void)dealloc
{
  self.name = nil;
  [super dealloc];
}

@end</code></pre>

That all looks good, right? No ivar cluttering up the class interface.

I disagree, the problem with this code is that the ivar that gets generated by default from this code is simply called <code>name</code> and it allows for easy slips with forgetting accessing the ivar directly to be written:

<pre><code class="prettyprint">// Direct ivar access bypassing property accessors
name = [NSString stringWithString:@"Dave"];</code></pre>

<pre><code class="prettyprint">// Access through synthesized property accessors
self.name = [NSString stringWithString:@"Dave"];</code></pre>

Obviously the memory management implications of these two lines of code are completely different and the first will cause an application to crash whenever the name property is accessed as the autoreleased variable is never retained as the property setter is never called.

<strong>I strongly believe that we should make it as hard as possible to make silly mistakes when coding</strong> and using implicit ivars with the same names as their properties makes it way too easy to make a mistake like the one above and I always prefix my ivars with an underscore to stop code like that from compiling.

But I would also love to take advantage of the automatic creation of ivars with the modern runtime and until recently I did not think this was possible but it is! You can omit the ivar declaration in the interface and just have a custom <code>synthesize</code> statement to force the automatic synthesis of ivars to use an alternate name for the ivar:

<pre><code class="prettyprint lang-c">@interface Person : NSObject

@property (retain) NSString *name;

@end</code></pre>

<pre><code class="prettyprint lang-c">@implementation Person

@synthesize name = _name;

- (void)dealloc
{
  self.name = nil;
  [super dealloc];
}

@end</code></pre>

Any code which attempts to access the <code>name</code> ivar will now cause a compiler error as the ivar is now called <code>_name</code>.

I am not sure it has always worked this way as I am sure I have tried this previously and not had the same results but with the latest Xcode 3/iOS SDK 4.2 this is certainly the state of things now and I have to say I am completely happy with how it works as it gives a good level of safety with only a minor inconvenience of adding a prefixed ivar name to the end of each synthesize statement.

The final thing to note here is that the application templates that ship with the latest beta of Xcode 4 have finally been updated to use this style of property declaration. This is really great news, thank you Apple! I wonder if the bug reports I filed helped get those changed.

<strong>Updated:</strong> Apparently Apple have <a href="http://twitter.com/#!/jeff_lamarche/status/34873215893381120">recently updated their docs to recommend that underscores are no longer used for property ivars</a> however the technique works just as well with any ivar prefix.

I hope this helps to clear this up for everyone as it has been the subject of a few questions on <a href="/iphone-training">the course</a> recently.